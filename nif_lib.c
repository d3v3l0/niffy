#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <erl_nif.h>
#include <setjmp.h>
#include <ucontext.h>

__thread static jmp_buf ret_buf;
__thread static ERL_NIF_TERM ret_term;
__thread static bool stack_inited = false;
__thread static void *stack;

// These are generated by the compiler.
// They contain functions that enable you to
// call a generated NIF function with a variable
// number of arguments.
int nifrt_callarg_wrappers_num;
void (**nifrt_callarg_wrappers)(void*, ErlNifEnv*, ERL_NIF_TERM*);
void (*nifrt_callarg_wrappers_arr[10])(void*, ErlNifEnv*, ERL_NIF_TERM*);

// ==================
// ==== Closures ====
// ==================

//typedef struct {
//    char *module;
//    char *name;
//    int env_num;
//    ErlNifEnv *env;
//    int captures_len;
//    ERL_NIF_TERM captures[];
//} lambda_environment_t;
//
//typedef struct {
//    lambda_environment_t *environment;
//    int lambda_num;
//    void *fun;
//} bound_lambda_t;
//
//ERL_NIF_TERM atom_error;
//
//ErlNifResourceType *lambda_environment_resource_type;
//ErlNifResourceType *bound_lambda_resource_type;
ErlNifResourceType *fun_ptr_resource_type;
ERL_NIF_TERM native_fun_atom;
ERL_NIF_TERM nil_atom;

void free_fun_ptr(ErlNifEnv *env, void *obj) {
}

//
//// Called at load. Opens the lambda resource type.
int on_load(ErlNifEnv *env) {
//    atom_error = enif_make_atom(env, "error");
//    lambda_environment_resource_type = 
//        enif_open_resource_type(env, NULL, "eir_lambda_environment", 
//                free_lambda_environment, ERL_NIF_RT_CREATE, NULL);
//    bound_lambda_resource_type = 
//        enif_open_resource_type(env, NULL, "eir_bound_lambda", 
//                free_bound_lambda, ERL_NIF_RT_CREATE, NULL);
    fun_ptr_resource_type =
        enif_open_resource_type(env, NULL, "niffy_fun_ptr",
                free_fun_ptr, ERL_NIF_RT_CREATE, NULL);
    native_fun_atom = enif_make_atom(env, "native_fun");
    nil_atom = enif_make_atom(env, "nil");
    return 0;
}

typedef struct {
    void (*fun)();
    int arity;
} fun_ptr_t;

ERL_NIF_TERM nifrt_make_fun_ptr(ErlNifEnv *env, void *inner_fun, int arity) {
    void *obj = enif_alloc_resource(fun_ptr_resource_type, sizeof(fun_ptr_t));
    fun_ptr_t *fun = (fun_ptr_t *) obj;

    fun->fun = inner_fun;
    fun->arity = arity;

    ERL_NIF_TERM ret = enif_make_resource(env, obj);
    enif_release_resource(obj);
    return ret;
}



void nifrt_unreachable_fail(int loc_id) {
    printf("unreachable!! (%d)", loc_id);
    exit(-1);
}

static void nifrt_ret_ok_cont(ErlNifEnv *env, ERL_NIF_TERM _closure_env, ERL_NIF_TERM result) {
    ret_term = result;
    longjmp(ret_buf, 1);
}
static void nifrt_ret_err_cont(ErlNifEnv *env, ERL_NIF_TERM _closure_env, ERL_NIF_TERM result) {
    ret_term = enif_raise_exception(env, result);
    longjmp(ret_buf, 2);
}

static ERL_NIF_TERM nifrt_make_fun_empty_env(ErlNifEnv *env, void *fun, int arity) {
    return enif_make_tuple3(
            env,
            native_fun_atom,
            nifrt_make_fun_ptr(env, fun, arity),
            nil_atom
            );
}

static void nifrt_inner_launchpad(ErlNifEnv *env, ERL_NIF_TERM *argv, int argc, void *nif_fun) {
    printf("Enter inner\n");
    // Store stack state
    if (!setjmp(ret_buf)) {
        printf("Callarg: %ld\n", (nifrt_callarg_wrappers + argc));
        // Call the appropriate callarg function, enter the actual NIF code
        //((*nifrt_callarg_wrappers) + argc)(nif_fun, env, argv);
        (nifrt_callarg_wrappers_arr[argc])(nif_fun, env, argv);
    }
}

ERL_NIF_TERM nifrt_launchpad(ErlNifEnv *env, ERL_NIF_TERM *argv, int argc, void *nif_fun) {
    printf("Enter launchpad\n");

    // If the stack hasn't been allocated for this thread, do that.
    if (!stack_inited) {
        stack = malloc(1048576);
        stack_inited = true;
    }

    // Reset ret term
    ret_term = 0;

    // Construct args to native NIF function
    // (ok_cont, err_cont, args..)
    ERL_NIF_TERM argsi[argc+3];
    argsi[0] = nil_atom;
    argsi[1] = nifrt_make_fun_empty_env(env, nifrt_ret_ok_cont, 2);
    argsi[2] = nifrt_make_fun_empty_env(env, nifrt_ret_err_cont, 2);
    for (int i = 0; i < argc; i++) {
        argsi[i+3] = argv[i];
    }

    for (int i = 0; i < argc+3; i++) {
        enif_fprintf(stdout, "arg: %T\n", argsi[i]);
    }

    // Set up contexts
    ucontext_t ret_ctx;
    ucontext_t exec_ctx;

    getcontext(&exec_ctx);
    exec_ctx.uc_stack.ss_sp = stack;
    exec_ctx.uc_stack.ss_size = 1048576;
    exec_ctx.uc_link = &ret_ctx;
    makecontext(&exec_ctx, (void(*)(void)) &nifrt_inner_launchpad, 4, env, argsi, argc+3, nif_fun);

    swapcontext(&ret_ctx, &exec_ctx);

    return ret_term;
}

void nifrt_return_cont(ErlNifEnv *env, void *closure_env, ERL_NIF_TERM ret) {
    ret_term = ret;
    longjmp(ret_buf, 1);
}

void nifrt_cont_call(ErlNifEnv *env, ERL_NIF_TERM cont, ERL_NIF_TERM ret) {
    int arity;
    const ERL_NIF_TERM *terms;
    int res;
    void *fun_void;

    if (enif_get_tuple(env, cont, &arity, &terms)) {
        if (arity == 3 && terms[0] == native_fun_atom) {
            res = enif_get_resource(env, terms[1], 
                    fun_ptr_resource_type, &fun_void);
            if (res) {
                enif_keep_resource(fun_void);
                fun_ptr_t *fun_ptr = (fun_ptr_t *) fun_void;
                if (fun_ptr->arity == 2) {
                    fun_ptr->fun(env, terms[2], ret);
                }
            }
        }
    }

    printf("Cont call fail!\n");
    exit(-1);
}
//
//// Constructs a new lambda environment. Argument 1-3 
//// (module, name, env_num) are used for debugging only,
//// and must be statically allocated.
//ERL_NIF_TERM make_lambda_environment(ErlNifEnv *env, char *module, 
//        char *name, uint64_t env_num,
//        uint64_t captures_len, ERL_NIF_TERM *captures) {
//
//    void *obj = enif_alloc_resource(lambda_environment_resource_type,
//            sizeof(lambda_environment_t) + (captures_len * sizeof(ERL_NIF_TERM)));
//    lambda_environment_t *lambda = (lambda_environment_t *) obj;
//
//    ErlNifEnv *env = enif_alloc_env();
//
//    lambda->module = module;
//    lambda->name = name;
//    lambda->env_num = env_num;
//    lambda->captures_len = captures_len;
//
//    for (int i = 0; i < captures_len; i++) {
//        container->captures[i] = enif_make_copy(env, captures[i]);
//    }
//
//    ERL_NIF_TERM ret = enif_make_resource(env, obj);
//    enif_release_resource(obj);
//    return ret;
//}
//
//// Binds a function with an environment resource.
//// The second argument is for debugging only.
//ERL_NIF_TERM make_bound_lambda(ErlNifEnv *env, uint64_t lambda_num, 
//        void *fun, ERL_NIF_TERM environment_term) {
//    int res;
//
//    void *environment_void;
//    res = enif_get_resource(env, environment_term, 
//            lambda_environment_resource_type, &environment_void);
//    if (!res) {
//        printf("Attempted to construct bound lambda with invalid environment\n");
//        *ret = atom_error;
//        return false;
//    }
//    enif_keep_resource(environment_void);
//    lambda_environment_t *environment = (lambda_environment_t *) environment_void;
//
//    void *obj = enif_alloc_resource(bound_lambda_resource_type, sizeof(bound_lambda_t));
//    lambda_env_t *bound = (lambda_env_t *) obj;
//
//    container->environment = environment;
//    container->lambda_num = lambda_num;
//    container->fun = fun;
//
//    ERL_NIF_TERM ret = enif_make_resource(env, obj);
//    enif_release_resource(obj);
//    return ret;
//}
//
//int call_apply(ERL_NIF_TERM *ret, ErlNifEnv *env, ERL_NIF_TERM function, ERL_NIF_TERM *args) {
//    void *resource_raw;
//    if (enif_get_resource(env, function, bound_lambda_resource_type, &resource)) {
//        bound_lambda_t *resource = (bound_lambda_t *) resource_raw;
//    }
//    
//    return 0;
//}
//
//// Frees a lambda environment. Called as a resource destructor.
//void free_lambda_environment(ErlNifEnv *env, void *obj) {
//    lambda_environment_t *obj_n = (lambda_environment_t *) obj; 
//
//    enif_free_env(obj_n->env);
//
//}
//
//void free_bound_lambda(ErlNifEnv *env, void *obj) {
//    bound_lambda_t *obj_n = (bound_lambda_t *) obj; 
//
//    enif_release_resource(obj_n->environment);
//
//}

// ==================================
// ==== Function implementations ====
// ==================================

// Function name mangling scheme is as follows:
// GNIF{module_len}_{module}{name_len}_{name}{arity}_{env_num}_{lambda_num}
//
// Mangling scheme of identifiers is as follows:
// "+" replaced by "_p"
// "_" replaced by "__"

// erlang:'+'/2
void GNIF6_erlang2__p2_n_n(ErlNifEnv* env, ERL_NIF_TERM c_env, 
        ERL_NIF_TERM ok_cont, ERL_NIF_TERM err_cont,
        ERL_NIF_TERM term1, ERL_NIF_TERM term2) {
    enif_fprintf(stdout, "WOO\n");
    enif_fprintf(stdout, "c_env: %T\n", c_env);
    enif_fprintf(stdout, "ok_cont: %T\n", ok_cont);
    enif_fprintf(stdout, "err_cont: %T\n", err_cont);
    enif_fprintf(stdout, "term1: %T\n", term1);
    enif_fprintf(stdout, "term2: %T\n", term2);
    int i1, i2;
    ERL_NIF_TERM ret;
    if (!enif_get_int(env, term1, &i1)) {
        ret = enif_make_atom(env, "badarith");
        nifrt_cont_call(env, err_cont, ret);
    }
    if (!enif_get_int(env, term2, &i2)) {
        ret = enif_make_atom(env, "badarith");
        nifrt_cont_call(env, err_cont, ret);
    }
    ret = enif_make_int(env, i1 + i2);
    nifrt_cont_call(env, ok_cont, ret);
}

// erlang:element/2
// erlang:is_list/1
// erlang:=</2
// lists:reverse/1
// maps:fold/3
// erlang:is_atom/1
// Elixir.Enumerable:reduce/3






